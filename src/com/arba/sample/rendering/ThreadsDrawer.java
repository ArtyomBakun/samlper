package com.arba.sample.rendering;import com.arba.sample.model.ThreadInfo;import com.arba.sample.util.AskJdkUtils;import com.arba.sample.util.RenderingUtils;import javafx.application.Platform;import javafx.collections.FXCollections;import javafx.collections.ObservableList;import javafx.scene.control.*;import javafx.stage.StageStyle;import java.util.ArrayList;import java.util.List;import java.util.Timer;import java.util.TimerTask;public class ThreadsDrawer extends Thread{    private Button deadlocksButton;    private Integer pid;    public boolean killed;    private TableView<ThreadInfo> threadsTable;    private ThreadInfo selectedThread;    private TextArea sampleInfoText;    private ObservableList<ThreadInfo> threads = FXCollections.observableArrayList();    public ThreadsDrawer(TableView<ThreadInfo> threadsTable,            TextArea sampleInfoText,            Button deadlocksButton, Integer pid)    {        this.pid = pid;        this.sampleInfoText = sampleInfoText;        this.threadsTable = threadsTable;        this.deadlocksButton = deadlocksButton;    }    @Override    public void run()    {        threadsTable.setItems(threads);        threadsTable.setOnMouseClicked(event -> {            selectedThread = threadsTable.getSelectionModel().getSelectedItem();            sampleInfoText.setText(getThreadStack());        });        deadlocksButton.setOnMouseClicked(event -> Platform.runLater(() -> {            StringBuilder report = new StringBuilder();            AskJdkUtils.detectDeadlocksForProcesses(pid).forEach(s -> report.append(s).append("\n"));            Alert alert = new Alert(Alert.AlertType.INFORMATION);            RenderingUtils.setIcon(alert);            alert.setTitle("Detect deadlocks report");            alert.setHeaderText("Report for process with PID " + pid);            alert.setResizable(true);            TextArea reportText = new TextArea(report.toString());            reportText.setPrefSize(600, 400);            alert.getDialogPane().setContent(reportText);            alert.show();        }));        Timer t = new Timer();        t.schedule(new TimerTask()        {            long count = 0;            @Override            public void run()            {                setName("Threads drawer" + count);                if(killed){                    t.cancel();                }                long l = System.currentTimeMillis();                parseCmdOutput();                System.out.println("com.arba.sample.rendering.ThreadsDrawer.parseCmdOutput call#" + count + " time#" + (System.currentTimeMillis() - l) + " ms");                RenderingUtils.refreshTableView(threadsTable);                if(selectedThread != null){                    sampleInfoText.appendText(selectedThread.getStacks().get(selectedThread.getStacks().size() - 1));                }                count++;            }        }, 0, 1500);    }        private void parseCmdOutput(){        List<String> threadSample = new ArrayList<>();        boolean isSample = false;        for (String s : AskJdkUtils.getThreadsDumpForProcesses(pid))        {            isSample |= s.startsWith("\"");            if(isSample){                if(s.trim().equals("")){                    extractThreadInfo(threadSample);                    threadSample = new ArrayList<>();                    isSample = false;                    continue;                }                threadSample.add(s);            }        }    }        private void extractThreadInfo(List<String> stack){        String name = stack.get(0).split("\"")[1];        ThreadInfo threadInfo = threads.stream()                .filter(t -> name.equals(t.getName()))                .findFirst()                .orElseGet(() -> {                    ThreadInfo t = new ThreadInfo();                    threads.add(t);                    return t;                });        threadInfo.setName(name);        threadInfo.setDaemon(stack.get(0).contains("daemon"));        threadInfo.getState().add(                stack.size() > 1                         ? stack.get(1).replace("java.lang.Thread.State:", "").trim()                         : "UNKNOWN");        StringBuilder threadStack = new StringBuilder();        stack.forEach(s -> threadStack.append(s).append("\n"));        threadInfo.getStacks().add(threadStack.toString());    }        private String getThreadStack(){        ObservableList<String> list = selectedThread.getStacks();        if(list != null && !list.isEmpty()){            StringBuilder stack = new StringBuilder();            list.forEach(s -> stack.append(s).append("\n"));            return stack.toString();        }        return "No stack available for this thread.";    }}